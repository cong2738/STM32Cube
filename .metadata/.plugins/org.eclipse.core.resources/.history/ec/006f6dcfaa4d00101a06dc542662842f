/*
 * ap_main.c
 *
 *  Created on: Jun 19, 2025
 *      Author: kccistc
 */

#include "ap_main.h"

enum {
	WATCH_MODE,
	STOPWATCH_MODE
};

enum {
	START,
    STOPWATCH,
    WATCH };

enum {
	STOP,
    RUN,
    CLEAR };

button_handler_t hBtnA;
button_handler_t hBtnB;
button_handler_t hBtnC;

typedef struct {
	uint32_t msec;
	uint32_t sec;
	uint32_t min;
}clock_data_type;


int ap_state = START;

void TIM2_IRQHandler(void) // 인터럽트 함수 Startup가보면 인터럽트벡터등 이름이 명시되어 있음
{
	if(ap_state != STOP) incTick();
    FND_DisplayData();
    TIM_ClearUIF(TIM2);
}

int ap_main()
{
	int ap_state = START;
	int swModeState = STOP;
	int mode = WATCH_MODE;
	clock_data_type clock[2];
    uint32_t WMODEprevCT = 0;
    while (1) {
    	if(getTick() - WMODEprevCT >= 100) {
    		WMODEprevCT = getTick();
    		clock[WATCH_MODE].msec++;
    	}
    	if(clock[WATCH_MODE].msec == 1000) {
    		clock[WATCH_MODE].sec++;
    		clock[WATCH_MODE].msec = 0;
    	}
    	if(clock[WATCH_MODE].sec == 60) {
    		clock[WATCH_MODE].min++;
    		clock[WATCH_MODE].sec = 0;
    	}
    	if(clock[WATCH_MODE].min == 10) {
    		clock[WATCH_MODE].min = 0;
    	}

        switch (ap_state) {
			case START:
				clock[0].msec = 0;
				clock[0].sec = 0;
				clock[0].min = 0;
				clock[1].msec = 0;
				clock[1].sec = 0;
				clock[1].min = 0;
				ap_state = STOP;
				break;
			case STOPWATCH:
				mode = STOPWATCH_MODE;
				switch (swModeState) {
					case STOP:
						if(Button_GetState(&hBtnA) == ACT_PUSHED)  mode = WATCH_MODE;
						else if (Button_GetState(&hBtnB) == ACT_PUSHED) {
							swModeState = RUN;
						} else if (Button_GetState(&hBtnC) == ACT_PUSHED) {
							swModeState = CLEAR;
						}
						break;
					case RUN:
						if(Button_GetState(&hBtnA) == ACT_PUSHED)  mode = WATCH_MODE;
						else if (Button_GetState(&hBtnB) == ACT_PUSHED) {
							swModeState = STOP;
						}
						if(getTick() - WMODEprevCT >= 100) {
							WMODEprevCT = getTick();
							clock[STOPWATCH_MODE].msec++;
						}
						if(clock[STOPWATCH_MODE].msec == 1000) {
							clock[STOPWATCH_MODE].sec++;
							clock[STOPWATCH_MODE].msec = 0;
						}
						if(clock[STOPWATCH_MODE].sec == 60) {
							clock[STOPWATCH_MODE].min++;
							clock[STOPWATCH_MODE].sec = 0;
						}
						if(clock[STOPWATCH_MODE].min == 10) {
							clock[STOPWATCH_MODE].min = 0;
						}
						break;
					case CLEAR:
						swModeState = STOP;
						break;
				}

				break;
			case WATCH:
				mode = WATCH_MODE;
				break;
        }
		FND_WtireData(
				clock[mode].msec+
				clock[mode].sec *10+
				clock[mode].min *1000);
    }

    return 0;
}

void ap_init()
{
    SystemClock_init();

    LedBar_Init();

    Button_Init(&hBtnSTOPWATCH, GPIOB, 5);
    Button_Init(&hBtnWATCH, GPIOB, 3);
    Button_Init(&hBtnOnSTOP, GPIOA, 10);

    FND_Init();

    //TIM2 EN, TIM2INTRF
    TIM_Init(TIM2, 16 - 1, 1000 - 1);
    TIM_CntStart(TIM2);
    TIM_UIEnable(TIM2);
    NVIC_EnableIRQ(TIM2_IRQn); // TIM2 interruft EN
}
