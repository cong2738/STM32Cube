/*
 * FND.c
 *
 *  Created on: Jun 20, 2025
 *      Author: kccistc
 */

#include "FND.h"

enum {DIGIT_1=0, DIGIT_10, DIGIT_100, DIGIT_1000};

typedef struct {
	GPIO_TypeDef *GPIOx;
	uint32_t pinNum;
}FND_TypeDef;

FND_TypeDef fndDigitCom[4] = {
		{GPIOA, 12}, 	// D4
		{GPIOC, 5}, 	// D3
		{GPIOC, 6}, 	// D2
		{GPIOC, 8} 		// D1
};

FND_TypeDef fndPin[8] = {
		{GPIOA, 11}, 	// A
		{GPIOB, 12}, 	// B
		{GPIOB, 2}, 	// C
		{GPIOB, 1}, 	// D
		{GPIOB, 15},	// E
		{GPIOB, 14},	// F
		{GPIOB, 13},	// G
		{GPIOC, 4},		// dp
};

void FND_Init()
{
    for (int i = 0; i < 4; i++) {
        GPIO_Init(fndDigitCom[i].GPIOx, fndDigitCom[i].pinNum, OUTPUT);
    }

    for (int i = 0; i < 8; i++) {
        GPIO_Init(fndPin[i].GPIOx, fndPin[i].pinNum, OUTPUT);
    }
}


static void FND_DispOn(int fndPos);
static void FND_DispOff(int fndPos);
static void FND_DispOffAll();
static void FND_DotPrint(uint32_t digitPos);
static void FND_DispDigit(uint16_t digit);

static uint16_t fndDispNum = 0; // fnd main data: fnd에 출력되는 실제 데이터
static uint16_t fndDotData = 0b0000;

// write fndDotData
void FND_WriteDotData(uint16_t data)
{
	fndDotData = data;
}

// write fndDispNum
void FND_WriteData(uint16_t data)
{
	fndDispNum = data;
}

// read fndDispNum
uint16_t FND_ReadData()
{
	return fndDispNum;
}

// display fndDispNum
void FND_DispData()
{
	static int digitPos = 0; // digit 위치
	// 인터럽트가 발생하면 한 자리씩 출력한다.
	digitPos = (digitPos+1) % 4;
	switch(digitPos)
	{
	case DIGIT_1:
		//FND_DispOff(digitPos);
		FND_DispOffAll();
		FND_DispDigit(fndDispNum%10);
		FND_DotPrint(digitPos);
		FND_DispOn(digitPos);
		break;
	case DIGIT_10:
		//FND_DispOff(digitPos);
		FND_DispOffAll();
		FND_DispDigit(fndDispNum/10%10);
		FND_DotPrint(digitPos);
		FND_DispOn(digitPos);
		break;
	case DIGIT_100:
		//FND_DispOff(digitPos);
		FND_DispOffAll();
		FND_DispDigit(fndDispNum/100%10);
		FND_DotPrint(digitPos);
		FND_DispOn(digitPos);
		break;
	case DIGIT_1000:
		//FND_DispOff(digitPos);
		FND_DispOffAll();
		FND_DispDigit(fndDispNum/1000%10);
		FND_DotPrint(digitPos);
		FND_DispOn(digitPos);
		break;
	}

}

void FND_DispOff(int fndPos)
{
	GPIO_WritePin(fndDigitCom[fndPos].GPIOx, fndDigitCom[fndPos].pinNum, PIN_SET);
}

void FND_DispOn(int fndPos)
{
	GPIO_WritePin(fndDigitCom[fndPos].GPIOx, fndDigitCom[fndPos].pinNum, PIN_RESET);
}

void FND_DispOffAll()
{
    for (int i=0; i<4; i++) {
        GPIO_WritePin(fndDigitCom[i].GPIOx, fndDigitCom[i].pinNum, PIN_SET);
    }
}


void FND_DotPrint(uint32_t digitPos){
	if(!() {
		GPIO_WritePin(fndPin[7].GPIOx, fndPin[7].pinNum, PIN_SET);
	}
}

void FND_DispDigit(uint16_t digit)
{
	const uint8_t segFont[10] = {
	    0x3F, // 0 => 00111111
	    0x06, // 1 => 00000110
	    0x5B, // 2 => 01011011
	    0x4F, // 3 => 01001111
	    0x66, // 4 => 01100110
	    0x6D, // 5 => 01101101
	    0x7D, // 6 => 01111101
	    0x07, // 7 => 00000111
	    0x7F, // 8 => 01111111
	    0x6F  // 9 => 01101111
	};

	for (int i=0; i<8; i++) {
		if ((segFont[digit] & (1<<i))) {
			GPIO_WritePin(fndPin[i].GPIOx, fndPin[i].pinNum, PIN_RESET);
		}
		else {
			GPIO_WritePin(fndPin[i].GPIOx, fndPin[i].pinNum, PIN_SET);
		}
	}

//	FND_DispOn();
}



void FND_WriteClock(uint8_t hour, uint8_t min)
{
    uint16_t data = (hour / 10) * 1000 +
                    (hour % 10) * 100 +
                    (min / 10) * 10 +
                    (min % 10);
    FND_WriteData(data);
}

void FND_WriteStopwatch(uint8_t min, uint8_t sec, uint32_t msec)
{
    uint16_t data = (min % 10) * 1000 +
                    (sec / 10) * 100 +
                    (sec % 10) * 10 +
                    (msec / 100 % 10);
    FND_WriteData(data);
}

//void FND_WriteClock(uint8_t hour, uint8_t min)
//{
//    uint8_t data[4];
//    data[0] = hour/10;
//    data[1] = hour%10;
//    data[2] = min/10;
//    data[3] = min%10;
//    FND_DispData();
//}


//void FND_WriteStopwatch(uint8_t min, uint8_t sec, uint8_t dsec)
//{
//    uint8_t data[4];
//    data[0] = min;
//    data[1] = sec/10;
//    data[2] = sec%10;
//    data[3] = dsec;
//    FND_DispData();
//}
